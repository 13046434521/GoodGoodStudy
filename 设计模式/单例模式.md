# 单例模式

## 目的

	使用单例模式的目的是，为了使JVM虚拟机中只存在一个该对象的实例。

## 单例的种类

	1. 饿汉式
	2. 懒汉式
	3. DCL双重检查模式
	4. 静态内部类模式
	5. 枚举式单例

### 1. 饿汉式
```java
/**
 * @author jtl
 * @date 2021/7/20 11:14
 * 饿汉式单例
 * 优点：线程安全的
 * 缺点：由于类加载时就会创建对象。从而会造成内存浪费。
 */

public class Hungry {
    private byte[] aaa = new byte[1024*1024*50];


    private Hungry(){
        System.out.println("饿汉式单例:"+Thread.currentThread().getName());
    }

    private static final Hungry sHungry = new Hungry();

    public static Hungry getInstance(){
        return sHungry;
    }

    public static void test(){
        System.out.println("我只是个静态方法");
    }
}
```
	优点：线程安全
	缺点：由于static修饰，所以在类加载时就会创建对象，可能造成不必要的内存浪费
	结论：不推荐该模式

### 2. 懒汉式

```java
/**
 * @author jtl
 * @date 2021/7/20 11:41
 * 懒汉式
 * 优点：不会造成内存浪费
 * 缺点：不加synchronized可能会造成线程安全问题
 *       加 synchronized 会造成性能浪费。
 *
 */

public class Lazy {
    private static Lazy sLazy ;

    private Lazy(){
        System.out.println("懒汉式："+Thread.currentThread().getName());
    }

    public static synchronized Lazy getInstance(){
        if (sLazy==null){
            sLazy = new Lazy();
        }

        return sLazy;
    }
}
```
	优点：线程安全，用到时才会创建对象。
	缺点：为了线程安全，用synchronized修饰了getInstance方法。会造成性能的浪费。
	结论：不推荐该模式

### 3. DCL模式

```java
/**
 * @author jtl
 * @date 2021/7/20 11:46
 * 双重检查模式单例
 * 优点：线程安全
 * 缺点：反射可以破坏单例
 * 注意：需加volatile，因为 new操作本身不是线程安全的。重排序会出现问题
 */

public class DCL {
    private static volatile DCL sDCL;

    private DCL() {
        System.out.println("双重检查模式：" + Thread.currentThread().getName());
    }

    public static DCL getInstance() {
        if (sDCL == null) {
            synchronized (DCL.class) {
                if (sDCL == null) {
                    //1.分配内存
                    //2.创建对象，初始化变量
                    //3.将对象指向内存地址
                    //java执行时，顺序可能是123也有可能是132。如果该类中有一个int a =10;的操作。
                    //多线程时可能造成 sDCL对象不为null，但是a尚未赋值还未0
                    sDCL = new DCL();
                }
            }
        }

        return sDCL;
    }
}
```
	缺点：利用反射可以创建该实例对象
	注意事项：由于new 操作是非原子性操作，可能进行指令重排序。造成错误。因此需要volatile修饰实例对象。
	结论：推荐该模式

### 4. 静态内部类模式

```java
/**
 * @author jtl
 * @date 2021/7/20 11:49
 * 静态内部类单例
 * 优点：线程安全
 * 缺点：反射可以破坏单例
 */

public class Holder {
    private Holder(){
        System.out.println("静态内部类单例："+Thread.currentThread().getName());
    }

    public static Holder getInstance() {
        return Inner.sHolder;
    }

    private static class Inner{
        private static final Holder sHolder = new Holder();
    }
}
```
	缺点：利用反射可以创建该实例对象
	结论：推荐该模式

### 5. 枚举式单例

```java
/**
 * @author jtl
 * @date 2021/7/20 11:57
 * 枚举单例模式
 */

enum EnumSingle {
    INSTANCE;
}
```
	优点：反射无法创建该实例对象。由JVM保证了线程安全性。
	结论：该模式实现了，线程安全，不浪费内存，不浪费性能。推荐该模式